-- Migration to create the exam readiness report table and calculation function.\n\n-- 1. Ensure rep_exam_readiness table exists with correct schema\nCREATE TABLE IF NOT EXISTS public.rep_exam_readiness (\n  user_id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,\n--   exam_type TEXT, -- Decided to omit as not clearly defined how to derive/input this yet\n  readiness_score NUMERIC,\n  weakest_subjects JSONB, -- Array of objects: [{ \"id\": uuid, \"name\": text, \"accuracy\": numeric }]\n  weakest_topics JSONB,   -- Array of objects: [{ \"id\": uuid, \"name\": text, \"accuracy\": numeric }]\n  calculated_at TIMESTAMPTZ DEFAULT NOW(),\n  created_at TIMESTAMPTZ DEFAULT NOW(),\n  updated_at TIMESTAMPTZ DEFAULT NOW()\n);\n\nALTER TABLE public.rep_exam_readiness ENABLE ROW LEVEL SECURITY;\n\n-- Allow users to read their own readiness report\nCREATE POLICY \"Users can read their own readiness report\" \n  ON public.rep_exam_readiness\n  FOR SELECT \n  USING (auth.uid() = user_id);\n\n-- Allow service role or background jobs to update the table\n-- Note: Cron job execution likely runs with service_role\nCREATE POLICY \"Allow service role full access\"\n  ON public.rep_exam_readiness\n  FOR ALL\n  USING (true) -- Applies to service_role, adjust if cron runs differently\n  WITH CHECK (true);\n\n-- Trigger function to update `updated_at` timestamp\nCREATE OR REPLACE FUNCTION set_updated_at() RETURNS TRIGGER AS $$\nBEGIN\n  NEW.updated_at = NOW();\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\n-- Apply trigger to rep_exam_readiness table\nDROP TRIGGER IF EXISTS set_rep_exam_readiness_updated_at ON public.rep_exam_readiness;\nCREATE TRIGGER set_rep_exam_readiness_updated_at\nBEFORE UPDATE ON public.rep_exam_readiness\nFOR EACH ROW EXECUTE FUNCTION set_updated_at();\n\n-- 2. Create fn_calculate_readiness function\nCREATE OR REPLACE FUNCTION public.fn_calculate_readiness(p_user_id UUID)\nRETURNS TABLE (\n  readiness_score NUMERIC,\n  weakest_subjects JSONB,\n  weakest_topics JSONB\n)\nLANGUAGE plpgsql\nSECURITY DEFINER -- Use definer security to access tables consistently\nSET search_path = public\nAS $$\nDECLARE\n  v_overall_accuracy NUMERIC := 0;\n  v_attempted_topics_count INT := 0;\n  v_total_studied_topics_count INT := 0;\n  v_coverage NUMERIC := 0;\n  v_avg_difficulty_normalized NUMERIC := 0;\n  v_readiness_score NUMERIC := 0;\n  v_weakest_subjects JSONB;\n  v_weakest_topics JSONB;\n  v_total_attempts INT := 0;\n  v_correct_attempts INT := 0;\n  -- Configuration constants\n  RECENT_DAYS CONSTANT INT := 30; -- How many days of data to consider\n  MIN_ATTEMPTS_THRESHOLD CONSTANT INT := 5; -- Min attempts to consider a subject/topic for weakness\n  WEAK_ACCURACY_THRESHOLD CONSTANT NUMERIC := 0.60; -- Accuracy below this is considered weak\n  MAX_WEAK_SUBJECTS CONSTANT INT := 3;\n  MAX_WEAK_TOPICS CONSTANT INT := 5;\nBEGIN\n  -- Calculate overall accuracy and average difficulty from recent attempts\n  WITH recent_attempts AS (\n    SELECT\n      eqa.is_correct,\n      CASE q.difficulty\n        WHEN \'Easy\' THEN 0.25\n        WHEN \'Medium\' THEN 0.50\n        WHEN \'Hard\' THEN 0.75\n        WHEN \'Conceptual\' THEN 0.60 -- Assign a value if needed\n        ELSE 0.50 -- Default if null or unexpected\n      END as difficulty_normalized\n    FROM evt_question_attempts eqa\n    JOIN questions q ON eqa.question_id = q.id\n    WHERE eqa.user_id = p_user_id\n      AND eqa.completed_at >= NOW() - (RECENT_DAYS * INTERVAL \'1 day\')\n      AND eqa.is_correct IS NOT NULL\n  )\n  SELECT \n    COUNT(*), \n    SUM(CASE WHEN is_correct THEN 1 ELSE 0 END),\n    AVG(difficulty_normalized)\n  INTO v_total_attempts, v_correct_attempts, v_avg_difficulty_normalized\n  FROM recent_attempts;\n\n  IF v_total_attempts > 0 THEN\n    v_overall_accuracy := v_correct_attempts::NUMERIC / v_total_attempts;\n  ELSE\n    v_overall_accuracy := 0;\n    v_avg_difficulty_normalized := 0.5; -- Default difficulty if no attempts\n  END IF;\n  \n  v_avg_difficulty_normalized := COALESCE(v_avg_difficulty_normalized, 0.5); -- Handle potential NULL if AVG returns NULL\n\n  -- Calculate coverage (percentage of unique studied topics attempted recently)\n  SELECT COUNT(DISTINCT topic_id) \n  INTO v_attempted_topics_count\n  FROM evt_question_attempts\n  WHERE user_id = p_user_id\n    AND completed_at >= NOW() - (RECENT_DAYS * INTERVAL \'1 day\')\n    AND topic_id IS NOT NULL;\n\n  SELECT COUNT(DISTINCT topic_id_normalized)\n  INTO v_total_studied_topics_count\n  FROM user_studied_topics\n  WHERE user_id = p_user_id;\n\n  IF v_total_studied_topics_count > 0 THEN\n    v_coverage := v_attempted_topics_count::NUMERIC / v_total_studied_topics_count;\n  ELSE\n    v_coverage := 0;\n  END IF;\n  v_coverage := LEAST(GREATEST(v_coverage, 0), 1); -- Clamp coverage between 0 and 1\n\n  -- Calculate final readiness score (weighted average)\n  v_readiness_score := (v_overall_accuracy * 0.6) + \n                       (v_coverage * 0.3) + \n                       ((1 - v_avg_difficulty_normalized) * 0.1);\ -- Higher difficulty slightly lowers readiness\n  v_readiness_score := LEAST(GREATEST(v_readiness_score * 100, 0), 100); -- Scale to 0-100 and clamp\n\n  -- Find weakest subjects\n  WITH subject_performance AS (\n    SELECT\n      s.id,\n      s.name,\n      COUNT(*) as attempts,\n      SUM(CASE WHEN eqa.is_correct THEN 1 ELSE 0 END)::NUMERIC / COUNT(*) as accuracy\n    FROM evt_question_attempts eqa\n    JOIN subjects s ON eqa.subject_id = s.id\n    WHERE eqa.user_id = p_user_id\n      AND eqa.completed_at >= NOW() - (RECENT_DAYS * INTERVAL \'1 day\')\n      AND eqa.is_correct IS NOT NULL\n    GROUP BY s.id, s.name\n    HAVING COUNT(*) >= MIN_ATTEMPTS_THRESHOLD\n  )\n  SELECT jsonb_agg(\n      jsonb_build_object(\n        \'id\', id,\n        \'name\', name,\n        \'accuracy\', ROUND(accuracy, 2)\n      ) \n      ORDER BY accuracy ASC\n    )\n  INTO v_weakest_subjects\n  FROM (\n    SELECT id, name, accuracy\n    FROM subject_performance\n    WHERE accuracy < WEAK_ACCURACY_THRESHOLD\n    ORDER BY accuracy ASC\n    LIMIT MAX_WEAK_SUBJECTS\n  ) AS top_weak_subjects;\n\n  -- Find weakest topics\n  WITH topic_performance AS (\n    SELECT\n      t.id,\n      t.name,\n      COUNT(*) as attempts,\n      SUM(CASE WHEN eqa.is_correct THEN 1 ELSE 0 END)::NUMERIC / COUNT(*) as accuracy\n    FROM evt_question_attempts eqa\n    JOIN topics t ON eqa.topic_id = t.id\n    WHERE eqa.user_id = p_user_id\n      AND eqa.completed_at >= NOW() - (RECENT_DAYS * INTERVAL \'1 day\')\n      AND eqa.is_correct IS NOT NULL\n    GROUP BY t.id, t.name\n    HAVING COUNT(*) >= MIN_ATTEMPTS_THRESHOLD\n  )\n  SELECT jsonb_agg(\n      jsonb_build_object(\n        \'id\', id,\n        \'name\', name,\n        \'accuracy\', ROUND(accuracy, 2)\n      ) \n      ORDER BY accuracy ASC\n    )\n  INTO v_weakest_topics\n  FROM (\n    SELECT id, name, accuracy\n    FROM topic_performance\n    WHERE accuracy < WEAK_ACCURACY_THRESHOLD\n    ORDER BY accuracy ASC\n    LIMIT MAX_WEAK_TOPICS\n  ) AS top_weak_topics;\n  \n  -- Return the results\n  RETURN QUERY SELECT \n    ROUND(v_readiness_score, 2) as readiness_score, \n    COALESCE(v_weakest_subjects, \'[]\'::jsonb) as weakest_subjects, \n    COALESCE(v_weakest_topics, \'[]\'::jsonb) as weakest_topics;\n\nEND;\n$$;\n\n-- Example usage (for testing in SQL editor):\n-- SELECT * FROM fn_calculate_readiness(\'YOUR_TEST_USER_ID\'::uuid);\n\n-- Function to update the rep_exam_readiness table for a specific user\nCREATE OR REPLACE FUNCTION public.update_user_readiness_report(p_user_id UUID)\nRETURNS void\nLANGUAGE plpgsql\nSECURITY DEFINER\nSET search_path = public\nAS $$\nDECLARE\n    v_readiness_score NUMERIC;\n    v_weakest_subjects JSONB;\n    v_weakest_topics JSONB;\nBEGIN\n    -- Calculate the readiness metrics\n    SELECT \n        readiness_score,\n        weakest_subjects,\n        weakest_topics\n    INTO \n        v_readiness_score,\n        v_weakest_subjects,\n        v_weakest_topics\n    FROM fn_calculate_readiness(p_user_id);\n\n    -- Insert or update the report table\n    INSERT INTO rep_exam_readiness (\n        user_id, \n        readiness_score, \n        weakest_subjects, \n        weakest_topics, \n        calculated_at\n    )\n    VALUES (\n        p_user_id, \n        v_readiness_score, \n        v_weakest_subjects, \n        v_weakest_topics, \n        NOW()\n    )\n    ON CONFLICT (user_id) DO UPDATE SET\n        readiness_score = EXCLUDED.readiness_score,\n        weakest_subjects = EXCLUDED.weakest_subjects,\n        weakest_topics = EXCLUDED.weakest_topics,\n        calculated_at = NOW();\nEND;\n$$;\n\n-- Example usage (for testing or manual trigger):\n-- SELECT update_user_readiness_report(\'YOUR_TEST_USER_ID\'::uuid);\n 